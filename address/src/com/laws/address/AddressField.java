/* Generated by Together */

package com.laws.address;

import java.io.Serializable;
import java.util.ArrayList;

import com.laws.util.BaseComparator;


public class AddressField extends BaseComparator<AddressField> implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = -9204994779723511027L;

	/**
	 * empty constructor
	 *
	 */
    public AddressField() {}

    /**
     * constructor
     * @param aft addressFieldType field
     * @param value the value field
     * @throws Exception
     */
    public AddressField(AddressFieldType aft, String value) throws Exception{
        addressFieldType = aft;
        this.setValue(value);
    }

    /**
     * getter for vlaue field
     * @return the string value
     */
	public String getValue(){ return value; }

	/**
	 * setter for value field
	 * @param value the value field
	 */
    public void setValue(String value) {
    	
        if(value!=null) {
        	this.value = value.trim();
        } 
        /*
        else if (addressFieldType!=null){
            this.value = addressFieldType.getDefaultValue();
        } else
        	this.value=null;
        if(addressFieldType!=null && 
        		(!addressFieldType.isValid(value)) ) {
			throw new InvalidValueException("\'"+value+"\' is invalid for field \'"
                +"\'"+addressFieldType.getName());
        } 
        */       
    }

	/**
	 * get a list of addresses that reference this AddressField
	 * @return Returns the addresses that reference this AddressField
	 */
	public java.util.List<Address> getAddresses() {
		return addresses;
	}
    /**
     * setter for addresses that reference this AddressField
     * This should not be used by applications. It is public only because
     * some frameworks (SQLMap) requires writable access to the property.
	 * @param addresses The addresses to set.
	 */
	public void setAddresses(java.util.List<Address> addresses) {
		this.addresses = addresses;
	}

	/**
	 * setter for locationCode
	 * @param key the locationCode
	 */
	public void setLocationCode(int key){ this.locationCode = key; }

	/**
	 * getter for locationCode
	 * @return the locationCode
	 */
	public int getLocationCode(){ return locationCode; }

    public Integer getAddressFieldID(){
            return addressFieldID;
        }

    /**
     * setter for the unique address field ID. This method should not
     * be used by the applicaitons. It is here only because some 
     * frameworks used by this component requires accessibility to this
     * method.
     * @param addressFieldID the unique field ID
     */
    public void setAddressFieldID(Integer addressFieldID){
            this.addressFieldID = addressFieldID;
        }

    /**
     * getter for addressFieldType
     * @return the AddressFieldType
     */
    public AddressFieldType getAddressFieldType(){
            return addressFieldType;
        }

    /**
     * setter for addressFieldType
     * @param addressFieldType
     */
    public void setAddressFieldType(AddressFieldType addressFieldType){
            this.addressFieldType = addressFieldType;
        }

    /**
     * @return string representing this AddressField
     */
	public String toString() {
		String suffix=addressFieldType.getSuffix();
	    return (value==null ? "" : value) 
		+ (suffix==null ? "" : suffix) + " ";
	}

	/** 
	 * test whether the two objects have the same addressFieldID
	 * @param other the other object to be compared with
	 * @return <code>true</code> same addressFieldID
	 * 	<code>false</code> different or <code>null</code> addressFieldID
	 */
	public boolean equals(Object other) {
		if (!(other instanceof AddressField))
			return false;
		AddressField af = (AddressField) other;
		boolean result = false;
		if(this.addressFieldID==null || af.getAddressFieldID()==null)
			return false;
		if (this.addressFieldID.equals(af.getAddressFieldID()) ) {
			result = true;
		}
		return result;
	}

	/**
	 * test whether the AddressField is valid
	 * @return <code>true</code> valid
	 * 	<code>false</code> otherwise.
	 */
	public boolean isValid() {
		return (addressFieldType!=null
				&& value!=null
				&& locationCode!=0
				);
	}

	/**
	 * A list of Address objects that reference to this AddressField.
	 * This should be lazy loaded by the O/R mapping layer.
	 * @directed directed
	 * @link aggregation <{com.laws.Address.Address}>
	 * @supplierCardinality 0..*
	 * @supplierRole addresses
	 */
	private java.util.List<Address> addresses = new ArrayList<Address>();

	/**
	 * string value of the AddressField
	 */
	private String value;
	/**
	 * hashcode representing the geographical location that this
	 * AddressField represents.
	 */
    private int locationCode;
    /**
     * unique ID
     */
    private Integer addressFieldID;

    /**
     * the AddressFieldType (containing meta data of the AddressField)
     * to refer to.
     * @clientCardinality   1
     * @supplierCardinality 0..1
     * @directed
     */
    private AddressFieldType addressFieldType;

	@Override
	public int compare(AddressField af1, AddressField af2) {
		int result=0;
		if (af1.getAddressFieldType().getHierarchyOrder()>af2.getAddressFieldType().getHierarchyOrder())
            result=1;
        else if(af1.getAddressFieldType().getHierarchyOrder()<af2.getAddressFieldType().getHierarchyOrder())
            result=-1;
        if(order==ASCENDING)
        	return result;
        else
        	return -result;
	}
}
