/* Generated by Together */

package com.laws.address;

import java.util.*;
import java.io.Serializable;

public class Address implements Serializable {
    /**
	 * 
	 */
	private static final long serialVersionUID = 2235013890986047654L;
	public Address(){}
    public Address(AddressStatus status) {
        setStatus(status);
    }
	
    /**
     * Test whether the Address is valid. It delegates the test to
     * to list of address fields.
     * @return <code>true</code> valid; 
     * 	<code>false</code> invalid
     */
    public boolean isValid() {
    	if(locationCode==0)
    		return false;
    	for(int i=0; i<addressFields.size(); i++){
    		AddressField af=(AddressField) addressFields.get(i);
    		if(!af.isValid())
    			return false;
    	}
    	return true;
    }	
	
    /**
     * get the unique ID for this Address.
     * @return unique ID for the address
     */
	public Integer getAddressID(){
            return addressID;
    }

	/**
	 * This is reserved for internal use only. It should not have been
	 * made public, but some frameworks used (e.g. SQLMap) requires 
	 * this method to be accessible.
	 * @param <code>addressID</code>
	 */
    public void setAddressID(Integer addressID){
            this.addressID = addressID;
    }

    /**
     * get the location code which represents the geographical location
     * of the address
     * @return the location code representing geographical location
     */
    public int getLocationCode(){
    	if(locationCode==0)
    		locationCode=this.generateLocationCode();
    	return locationCode; 
    }

    /**
     * setter for locationCode
     * @param the locationCode
     */
    public void setLocationCode(int key){ this.locationCode = key; }

    /**
     * getter for the Address status.
     * @return status
     * @see AddressStatus
     */
    public AddressStatus getStatus(){ return status; }

    /**
     * setter for status field
     * @param status
     */
    public void setStatus(AddressStatus status){
    	if(status==AddressStatus.ACTIVE)
    		this.status = status;
    	else
    		this.status = AddressStatus.INACTIVE;
    }

    /**
     * prinits the string form of the address. It concatenates the
     * sorted address fields values to form the string.
     * @see AddressFieldComparator
     */
    public String toString() {
        StringBuffer sb=new StringBuffer();
        Object[] fields=addressFields.toArray();
        Arrays.sort(fields);
        if(fields.length>0) {
	        for (int i=0; i<fields.length; i++) {
	            AddressField af=(AddressField)fields[i];
	            if(af.getValue()!=null) {
	            	sb.append(af.toString());
	            }
	        }
	        return sb.toString().trim();
        } else
        	return " ";
    }

    /**
     * Generate a locationCode for the address based on all its address fields values. The locationCode provides a way of doing a quick (negative) comparison between two address objects without comparing each field. If the locationCode values match, then the field values can be used to do another round of comparison to ensure that the two address objects are equal.
     * @return a locationCode which is generated based on the fields of the address object 
     */
    public int generateLocationCode() {
    	// generate the partial location code for the address fields
    	for(int i=0; i<addressFields.size(); i++){
    		AddressField af=(AddressField) addressFields.get(i);
    		af.setLocationCode(this.generateAddressFieldCode(af.getAddressFieldType()));
    	}
        setLocationCode(toString().toUpperCase().hashCode());
        return getLocationCode();
    }

    /**
     * generates location code for a portion of the address starting
     * from the aft. It uses the address field types with hierarchy 
     * orders equal or greater than the passed in aft parameter.
     * e.g. locationCode can be generated for the 
     * <p>"Pitt Street Sydney NSW 2000" portion of the whole 
     * <p>"Level 2, 100 Pitt Street Sydney NSW 2000" address
     * @param aft the AddressFieldType
     * @return locationCode generated for the portion of the address whoes address field type orders are equal or greater than the aftID parameter. 
     */
    protected int generateAddressFieldCode(AddressFieldType aft) {
		return getPartialAddress(aft).toUpperCase().hashCode();
    }

    /**
     * generates the portion of the address whoes address field type 
     * hierarchy orders are equal or greater than the aft parameter. 
     * e.g. address string can be generated for the 
     * <p>"Pitt Street Sydney NSW 2000" portion of the whole 
     * <p>"Level 2, 100 Pitt Street Sydney NSW 2000" address
     * @param aft - the AddressFieldType
     * @return the portion of the address whoes address field type orders are equal or greater than the aftID parameter.
     */
    public String getPartialAddress(AddressFieldType aft) {
        StringBuffer sb=new StringBuffer();
        for(int i=0; i<addressFields.size(); i++) {
            AddressField af=(AddressField)addressFields.get(i);
            //if(af.getAddressFieldType().getAddressFieldTypeID().compareTo(aft.getAddressFieldTypeID()) >= 0) {
            if(af.getAddressFieldType().getHierarchyOrder() >= aft.getHierarchyOrder()) {
                sb.append( af.toString() );
            }
        }
        return sb.toString().trim();
    }

    /**
     * getter for addressFields
     * @return the addressFields list
     */
    public List<AddressField> getAddressFields() {
        return addressFields;
    }
    /**
     * setter for addressFields
     * @param the list of AddressField
     */
    public void setAddressFields(List<AddressField> addressFields){ 
    	this.addressFields = addressFields; 
    }

    /**
     * get the AddressField from the addressFields list with matching
     * AddressFieldType identified by addressFieldTypeID
     * @param addressFieldTypeID identifying the AddressFieldType
     * @return addressField with matching AddressFieldType; null if not found
     */
    public AddressField getAddressFieldByType(Integer addressFieldTypeID){
        for (int i=0; i<addressFields.size(); i++) {
			AddressField currentAf=(AddressField)addressFields.get(i);
            if(currentAf.getAddressFieldType().getAddressFieldTypeID().equals(addressFieldTypeID)) {
                return currentAf;
            }
        }
	    return null;
    }
    /**
     * Adds the address field to the address' addressFields list
     * if the af already exists, it replaces the old one.
     * @param af the AddressField to be added
     */
    public void setAddressField(AddressField af) {
        for (int i=0; i<addressFields.size(); i++) {
			AddressField currentAf=(AddressField)addressFields.get(i);
			// update
			if(currentAf.getAddressFieldType().getHierarchyOrder()==af.getAddressFieldType().getHierarchyOrder()) {
				addressFields.remove(i);
				addressFields.add(i, af);
				return;
			// add new
			} else if(currentAf.getAddressFieldType().getHierarchyOrder()>af.getAddressFieldType().getHierarchyOrder()) {
                addressFields.add(i, af);                
                return;
            }
        }
        addressFields.add(af);        
        return;
    }
    /**
     * get the string value of the AddressField in the addressFields
     * list with matching AddressFieldType.name.
     * @param addressFieldName the AddressFieldType.name to be matched
     * @return string value of the matching AddressField
     */
    public String getAddressFieldValue(String addressFieldName) {
        for(int i=0; i<addressFields.size(); i++) {
            AddressField af=(AddressField) addressFields.get(i);
            if(af.getAddressFieldType().getName().equals(addressFieldName)) {
                return af.getValue();
            }
        }
        return null;
    }

    /**
     * Test whether the two addresses are identical, ie whether 
     * they refer to the same physical location. 
     * It does this by comparing the AddressField data inside 
     * the two address objects. Note that identical addresses can be
     * different objects (or database records) with different 
     * addressID values.
     * @param other the other Address object to be compared with.
     * @return <code>true</code> the two addresses are in the same location; 
     * 	<code>false</code>otherwise.
     */
    public boolean identical(Object other) {
    	if(!(other instanceof Address))
    		return false;
    	Address a = (Address)other;
        boolean result=false;
        if(a.getLocationCode()==this.getLocationCode()) {
			result=a.toString().equals(toString());
        }
        return result;
    }
    
    /**
     * Test whether the two Address objects are the same object 
     * by comparing the unique addressIDs.
     * @param <code>other</code> the other object to be compared with.
     * @return <code>true</code> two Address objects are equal (same row in database)
     * 		<code>false</code>otherwise.
     */
    public boolean equals(Object other) {
    	if(!(other instanceof Address))
    		return false;
    	Address a = (Address)other;
        boolean result=false;
        if(a.getAddressID()==null || this.addressID==null)
        	return false;
        
        if(a.getAddressID().equals(this.addressID)) {
			result=true;
        }
        return result;
    }

    /**
     * unique ID for each Address object. This should be generated by
     * the system - by the database, or the O/R mapping layer. 
     * It should never be set by the application.
     */
    private Integer addressID;

	/**
	 * list of AddressFields in the Address, representing the fields
	 * which collectively form a physical location.
	 * @associates <{com.laws.Address.AddressField}>
	 * @clientCardinality 1
	 * @link aggregation
	 * @supplierCardinality 0..*
	 * @supplierConstraint {ordered}
	 * @supplierRole addressFields
	 */
    private List<AddressField> addressFields = new java.util.ArrayList<AddressField>();
    /**
     * a hashcode to represent a unique geographical location.
     */
    private int locationCode;
    /**
     * status of the address
     * @see AddressStatus
     */
    private AddressStatus status;
}
